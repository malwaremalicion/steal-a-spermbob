<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Steal A Spermbob — Multiplayer</title>
<style>
  :root{--muted:#9aa6b2}
  html,body{height:100%;margin:0;background:linear-gradient(#071018,#001018);font-family:Inter,Arial,sans-serif;color:#e6eef8}
  #top{position:fixed;left:0;right:0;top:0;height:56px;display:flex;align-items:center;padding:8px 12px;gap:12px;background:rgba(0,0,0,0.18);z-index:40}
  #money{font-weight:700} #status{margin-left:auto;color:var(--muted)}
  #playerList{position:fixed;left:12px;top:68px;background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;z-index:40;min-width:160px}
  #game{padding:84px 12px 12px 200px}
  #roadPanel{background:linear-gradient(#05202b,#021018);border-radius:8px;padding:12px;max-width:100%;overflow:hidden}
  #road{height:180px;background:linear-gradient(#0b2630,#041018);position:relative;overflow:hidden;border-radius:6px}
  .walker{position:absolute;display:flex;flex-direction:column;align-items:center;user-select:none;pointer-events:auto}
  .walker img{width:44px;height:44px;display:block}
  .walker .label{font-size:12px;color:#fff;text-shadow:0 0 3px #000;margin-top:6px;max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:center}
  .panel{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;margin-top:12px}
  .collectionsRow{display:flex;flex-direction:column;gap:12px;max-height:60vh;overflow:auto}
  .collection{background:rgba(255,255,255,0.01);padding:8px;border-radius:8px}
  .slots{display:flex;gap:8px;flex-wrap:wrap}
  .slot{width:64px;height:64px;border-radius:8px;background:#0b1720;border:1px solid rgba(255,255,255,0.03);position:relative;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .slot img{width:56px;height:56px}
  .slot .meta{position:absolute;bottom:2px;left:4px;right:4px;text-align:center;font-size:11px}
  .stealBar{position:absolute;left:0;bottom:0;height:6px;background:linear-gradient(90deg,#ef4444,#f97316);width:0%}
  #usernameModal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:100}
  .card{background:#07161a;padding:18px;border-radius:12px;width:340px}
  button,input{font-family:inherit}
</style>
</head>
<body>
<div id="top">
  <div id="money">Money: $<span id="moneyVal">30</span></div>
  <div id="roomShow">Room: <span id="roomLabel">—</span></div>
  <div id="status">Not connected</div>
</div>

<div id="playerList"><strong>Players</strong><div id="playersNames">—</div></div>

<div id="game">
  <div id="roadPanel">
    <h3 style="margin:6px 0">Road</h3>
    <div id="road"></div>
  </div>

  <div class="panel">
    <div style="display:flex;gap:8px">
      <input id="roomCode" placeholder="room code" style="flex:1;padding:8px;border-radius:8px;border:0;background:#051218;color:#e6eef8">
      <button id="hostBtn">Host</button>
      <button id="joinBtn">Join</button>
    </div>
    <div style="margin-top:8px" class="panel">
      <strong>Your and Others' Collections</strong>
      <div id="collectionsArea" class="collectionsRow"></div>
    </div>
  </div>
</div>

<div id="usernameModal">
  <div class="card">
    <h2 style="margin:0 0 8px 0">Choose a username</h2>
    <input id="usernameInput" placeholder="username" style="width:100%;padding:8px;border-radius:8px;border:0;background:#08131a;color:#e6eef8">
    <div style="display:flex;gap:8px;margin-top:12px">
      <input id="roomInput" placeholder="room code (pick any)" style="flex:1;padding:8px;border-radius:8px;border:0;background:#08131a;color:#e6eef8">
      <button id="enterBtn">Enter</button>
    </div>
    <div style="margin-top:10px;color:var(--muted)">Music will start after you join.</div>
  </div>
</div>

<audio id="bgm" src="bgm.mp3" loop></audio>

<script>
/* CONFIG */
const WS_URL = 'wss://spermbob-server-production.up.railway.app';
const WALKER_DURATION = 10000; // client travel time (ms) — matches server lifetime
const SELL_HOLD_MS = 5000;
const STEAL_TIMEOUT_MS = 15000;
const COLLECTION_SLOTS = 8;

/* STATE */
let ws = null;
let myId = null;
let username = null;
let roomCode = null;
let players = {};          // server snapshot
let localWalkers = {};     // id -> { walker, el, spawnTime }

/* DOM */
const moneyVal = document.getElementById('moneyVal');
const statusEl = document.getElementById('status');
const road = document.getElementById('road');
const playersNames = document.getElementById('playersNames');
const collectionsArea = document.getElementById('collectionsArea');
const roomLabel = document.getElementById('roomLabel');
const usernameModal = document.getElementById('usernameModal');
const usernameInput = document.getElementById('usernameInput');
const roomInput = document.getElementById('roomInput');
const enterBtn = document.getElementById('enterBtn');
const bgm = document.getElementById('bgm');

/* UI: username flow */
enterBtn.addEventListener('click', () => {
  const name = usernameInput.value.trim();
  const rc = roomInput.value.trim() || Math.random().toString(36).slice(2,6);
  if (!name) return alert('Pick a username');
  username = name; roomCode = rc;
  usernameModal.style.display = 'none';
  roomLabel.textContent = roomCode;
  // play BGM on user gesture
  bgm.play().catch(()=>{});
  connectWS();
});

document.getElementById('hostBtn').addEventListener('click', ()=>{
  const c = Math.random().toString(36).slice(2,6);
  document.getElementById('roomCode').value = c;
});
document.getElementById('joinBtn').addEventListener('click', ()=>{
  const c = document.getElementById('roomCode').value.trim();
  if (!c) return alert('enter room code');
  roomCode = c;
  roomLabel.textContent = roomCode;
  // if already connected, request join; else modal will handle initial connect
  if (ws && ws.readyState === WebSocket.OPEN) {
    safeSend({ type:'joinRoom', roomCode, username });
  } else {
    usernameModal.style.display = 'none';
    connectWS();
  }
});

/* WS helpers */
function setStatus(s){ statusEl.textContent = s; }
function safeSend(obj){
  if (ws && ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify(obj));
}

/* Connect */
let reconnectTimer = null;
function connectWS(){
  if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
  setStatus('Connecting...');
  ws = new WebSocket(WS_URL);
  ws.addEventListener('open', ()=> {
    setStatus('Connected');
    safeSend({ type:'joinRoom', roomCode, username, money:30 });
  });
  ws.addEventListener('message', ev => {
    let msg;
    try { msg = JSON.parse(ev.data); } catch(e) { return; }
    handleServer(msg);
  });
  ws.addEventListener('close', ()=> {
    setStatus('Disconnected — reconnecting...');
    // clear local walkers
    Object.values(localWalkers).forEach(e => e.el.remove());
    localWalkers = {};
    clearTimeout(reconnectTimer);
    reconnectTimer = setTimeout(connectWS, 2000);
  });
  ws.addEventListener('error', ()=> setStatus('Connection error'));
}

/* Handle server messages */
function handleServer(msg){
  if (msg.type === 'roomUpdate') {
    players = msg.players || {};
    // server gives you id in `you`
    if (msg.you) myId = msg.you;
    // update money UI if server has authoritative copy
    if (myId && players[myId]) moneyVal.textContent = Math.floor(players[myId].money || 30);
    // reconcile walkers snapshot: server sends full walkers array
    if (Array.isArray(msg.walkers)) {
      const serverIds = new Set(msg.walkers.map(w=>w.id));
      // add missing
      msg.walkers.forEach(w => { if (!localWalkers[w.id]) spawnLocalWalker(w); });
      // remove locals that server no longer has
      Object.keys(localWalkers).forEach(id => { if (!serverIds.has(id)) removeLocalWalker(id); });
    }
    renderCollections();
    renderPlayerList();
    return;
  }

  if (msg.type === 'walkerSpawn' && msg.walker) {
    spawnLocalWalker(msg.walker);
    return;
  }

  if (msg.type === 'walkerRemove' && msg.id) {
    removeLocalWalker(msg.id);
    return;
  }

  if (msg.type === 'buyResult') {
    if (!msg.success) {
      alert('Buy failed: ' + (msg.reason || 'unknown'));
    } else {
      // server will broadcast roomUpdate with authoritative collection & money soon
      // we can optionally overlay small success feedback (left as console)
      console.log('Buy success slot', msg.slot);
    }
    return;
  }

  if (msg.type === 'stealStart') {
    startStealUI(msg.thiefId, msg.victimId, msg.slot);
    if (msg.victimId === myId) alert(`SOMEONE IS STEALING YOUR SLOT ${msg.slot} — press arrow keys to block`);
    return;
  }
  if (msg.type === 'stealBlocked' || msg.type === 'stealSuccess') {
    stopStealUI(msg.victimId, msg.slot);
    // roomUpdate will update collections; we call render to be safe
    renderCollections();
    return;
  }
}

/* Local walker spawn/render */
function spawnLocalWalker(w) {
  if (localWalkers[w.id]) return;
  const el = document.createElement('div');
  el.className = 'walker';
  el.dataset.id = w.id;

  const img = document.createElement('img');
  img.src = w.type === 'bellbob' ? 'bellbob.png' : 'spermbob.png';
  // tint drop-shadow
  const tintMap = { 'Common':'drop-shadow(0 0 6px rgba(255,255,255,0.06))', 'Uncommon':'drop-shadow(0 0 8px rgba(0,255,120,0.10))', 'Rare':'drop-shadow(0 0 8px rgba(0,120,255,0.14))', 'Epic':'drop-shadow(0 0 10px rgba(200,50,255,0.16))' };
  img.style.filter = tintMap[w.rarity] || '';
  el.appendChild(img);

  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = `${w.rarity} • $${w.cost}`;
  el.appendChild(label);

  // ensure label won't overlap offscreen — we'll adjust after layout
  el.style.left = '-80px';
  el.style.top = (8 + Math.random() * (road.clientHeight - 64)) + 'px';
  road.appendChild(el);

  // reposition label if would overflow when placed along road; we'll handle dynamically during animation too
  localWalkers[w.id] = { walker: w, el, spawnTime: performance.now() };

  // click to buy
  el.addEventListener('click', () => {
    if (!ws || ws.readyState !== WebSocket.OPEN || !myId) { alert('Not connected'); return; }
    safeSend({ type: 'buyRequest', itemId: w.id });
  });
}

/* Remove local walker */
function removeLocalWalker(id) {
  const e = localWalkers[id];
  if (!e) return;
  try { e.el.remove(); } catch(_) {}
  delete localWalkers[id];
}

/* Animate walkers: client-side smooth movement over WALKER_DURATION */
let lastFrame = performance.now();
function animate(now) {
  const dt = now - lastFrame;
  lastFrame = now;
  const roadWidth = Math.max(1, road.clientWidth - 64); // subtract sprite
  for (const id in localWalkers) {
    const entry = localWalkers[id];
    const elapsed = now - entry.spawnTime;
    const t = Math.min(1, elapsed / WALKER_DURATION);
    entry.el.style.left = Math.round(t * roadWidth) + 'px';
    // label repositioning (Option C): ensure label fits horizontally and vertically
    const label = entry.el.querySelector('.label');
    if (label) {
      // compute label bounding if centered under sprite
      const labelWidth = Math.min(120, label.offsetWidth || 80);
      const leftPx = parseInt(entry.el.style.left || '0', 10);
      // if label would overflow right edge, move it to the left of sprite
      if (leftPx + 22 + labelWidth > roadWidth + 64) { // 22 is half sprite approx
        label.style.position = 'absolute';
        label.style.left = (-(labelWidth + 6)) + 'px';
        label.style.bottom = '0px';
      } else if (leftPx < labelWidth / 2) {
        // would overflow left
        label.style.position = 'absolute';
        label.style.left = '6px';
        label.style.bottom = '0px';
      } else {
        // normal under-sprite centered
        label.style.position = '';
        label.style.left = '';
        label.style.bottom = '';
      }
      // if label would overflow vertical bounds of road, move it above the sprite
      const topPx = parseInt(entry.el.style.top || '0', 10);
      if (topPx + 44 + 18 > road.clientHeight) { // sprite height + label height
        label.style.bottom = (44 + 6) + 'px'; // place above sprite
      }
    }

    if (t >= 1) {
      // finished walking -> remove locally (server will also remove after lifetime if still present)
      entry.el.remove();
      delete localWalkers[id];
    }
  }
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* Render players & collections */
function renderPlayerList() {
  playersNames.innerHTML = '';
  const ids = Object.keys(players);
  ids.forEach(id => {
    const d = document.createElement('div');
    d.textContent = players[id].username || 'player';
    playersNames.appendChild(d);
  });
}

function renderCollections() {
  collectionsArea.innerHTML = '';
  // order: show self first if available
  let ids = Object.keys(players);
  if (myId && players[myId]) {
    ids = [myId, ...ids.filter(i => i !== myId)];
  }
  ids.forEach(id => {
    const p = players[id];
    const block = document.createElement('div'); block.className = 'collection';
    const title = document.createElement('div'); title.style.fontWeight='700'; title.style.marginBottom='6px';
    title.textContent = p.username || 'player';
    block.appendChild(title);
    const slots = document.createElement('div'); slots.className = 'slots';
    (p.collection || Array(COLLECTION_SLOTS).fill(null)).forEach((it, idx) => {
      const slot = document.createElement('div'); slot.className = 'slot';
      if (it) {
        const img = document.createElement('img');
        img.src = it.type === 'bellbob' ? 'bellbob.png' : 'spermbob.png';
        img.style.filter = (it.rarity && ({ 'Common':'drop-shadow(0 0 6px rgba(255,255,255,0.06))', 'Uncommon':'drop-shadow(0 0 8px rgba(0,255,120,0.10))', 'Rare':'drop-shadow(0 0 8px rgba(0,120,255,0.14))', 'Epic':'drop-shadow(0 0 10px rgba(200,50,255,0.16))' })[it.rarity]) || '';
        slot.appendChild(img);
        const meta = document.createElement('div'); meta.className='meta'; meta.textContent = `${it.rarity} • $${it.mps}/s`;
        slot.appendChild(meta);
        if (id === myId) attachHoldSell(slot, idx);
        else attachHoldSteal(slot, idx, id);
      } else {
        slot.style.opacity = 0.5;
      }
      slots.appendChild(slot);
    });
    block.appendChild(slots);
    collectionsArea.appendChild(block);
  });
}

/* Sell: hold 5s or right-click */
function attachHoldSell(el, slotIndex) {
  let raf = null, start = null, bar = null;
  function tick(ts) {
    if (!start) start = ts;
    const pct = Math.min((ts - start) / SELL_HOLD_MS, 1);
    if (bar) bar.style.width = (pct * 100) + '%';
    if (pct >= 1) {
      cancel();
      safeSend({ type: 'sell', slot: slotIndex });
    } else raf = requestAnimationFrame(tick);
  }
  function startHold() {
    if (bar) bar.remove();
    bar = document.createElement('div'); bar.className = 'stealBar';
    el.appendChild(bar);
    start = null; raf = requestAnimationFrame(tick);
  }
  function cancel() { if (raf) cancelAnimationFrame(raf); raf = null; start = null; if (bar) { bar.remove(); bar = null; } }
  el.addEventListener('mousedown', e => { if (e.button !== 0) return; startHold(); });
  el.addEventListener('mouseup', cancel);
  el.addEventListener('mouseleave', cancel);
  el.addEventListener('contextmenu', e => { e.preventDefault(); safeSend({ type: 'sell', slot: slotIndex }); });
}

/* Steal: hold to start local bar, server times the steal; victim can block via arrow keys */
const activeStealBars = {}; // victim_slot -> interval/bar
function attachHoldSteal(el, slotIndex, victimId) {
  let raf = null, start = null, bar = null;
  function tick(ts) {
    if (!start) start = ts;
    const pct = Math.min((ts - start) / STEAL_TIMEOUT_MS, 1);
    if (bar) bar.style.width = (pct * 100) + '%';
    if (pct >= 1) { cancel(); /* server will perform transfer */ } else raf = requestAnimationFrame(tick);
  }
  function startHold() {
    if (bar) bar.remove();
    bar = document.createElement('div'); bar.className = 'stealBar';
    el.appendChild(bar);
    safeSend({ type: 'stealStart', victimId, slot: slotIndex });
    start = null; raf = requestAnimationFrame(tick);
  }
  function cancel() { if (raf) cancelAnimationFrame(raf); raf = null; start = null; if (bar) { bar.remove(); bar = null; } }
  el.addEventListener('mousedown', e => { if (e.button !== 0) return; startHold(); });
  el.addEventListener('mouseup', cancel); el.addEventListener('mouseleave', cancel);
}

/* server-initiated steal UI helpers */
function startStealUI(thiefId, victimId, slot) {
  // find victim block and add bar
  const collections = document.querySelectorAll('.collection');
  let found = null;
  collections.forEach(block => {
    const title = block.querySelector('div');
    if (title && title.textContent === (players[victimId]?.username || 'player')) found = block;
  });
  if (!found) return;
  const slotEls = found.querySelectorAll('.slot');
  const slotEl = slotEls[slot];
  if (!slotEl) return;
  const key = `${victimId}_${slot}`;
  if (activeStealBars[key]) return;
  const bar = document.createElement('div'); bar.className = 'stealBar';
  slotEl.appendChild(bar);
  let progress = 0;
  const interval = setInterval(() => {
    progress++;
    bar.style.width = (progress * 100 / (STEAL_TIMEOUT_MS / 1000)) + '%';
    if (progress >= (STEAL_TIMEOUT_MS / 1000)) {
      clearInterval(interval);
      if (bar) bar.remove();
      delete activeStealBars[key];
    }
  }, 1000);
  activeStealBars[key] = { bar, interval };
}

function stopStealUI(victimId, slot) {
  const key = `${victimId}_${slot}`;
  const ent = activeStealBars[key];
  if (!ent) return;
  clearInterval(ent.interval);
  if (ent.bar) ent.bar.remove();
  delete activeStealBars[key];
}

/* arrow-key defense */
document.addEventListener('keydown', e => {
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
    if (!myId) return;
    // best-effort: when victim presses key, tell server to block steals targeted at them
    safeSend({ type: 'stealBlocked', victimId: myId, slot: null }); // server will match slot(s)
  }
});

/* helpers to render players/collections */
function renderPlayerList() {
  playersNames.innerHTML = '';
  Object.keys(players).forEach(id => {
    const d = document.createElement('div');
    d.textContent = players[id].username || 'player';
    playersNames.appendChild(d);
  });
}

function renderCollections() {
  collectionsArea.innerHTML = '';
  // prefer self first
  let ids = Object.keys(players);
  if (myId && players[myId]) ids = [myId, ...ids.filter(i=>i!==myId)];
  ids.forEach(id => {
    const p = players[id];
    const block = document.createElement('div'); block.className = 'collection';
    const title = document.createElement('div'); title.style.fontWeight='700'; title.style.marginBottom='6px';
    title.textContent = p.username || 'player';
    block.appendChild(title);
    const slots = document.createElement('div'); slots.className = 'slots';
    (p.collection || Array(COLLECTION_SLOTS).fill(null)).forEach((it, idx) => {
      const slot = document.createElement('div'); slot.className = 'slot';
      if (it) {
        const img = document.createElement('img'); img.src = it.type === 'bellbob' ? 'bellbob.png' : 'spermbob.png';
        img.style.filter = (it.rarity && ({ 'Common':'drop-shadow(0 0 6px rgba(255,255,255,0.06))', 'Uncommon':'drop-shadow(0 0 8px rgba(0,255,120,0.10))', 'Rare':'drop-shadow(0 0 8px rgba(0,120,255,0.14))', 'Epic':'drop-shadow(0 0 10px rgba(200,50,255,0.16))' })[it.rarity]) || '';
        slot.appendChild(img);
        const meta = document.createElement('div'); meta.className='meta'; meta.textContent = `${it.rarity} • $${it.mps}/s`;
        slot.appendChild(meta);
        if (id === myId) attachHoldSell(slot, idx);
        else attachHoldSteal(slot, idx, id);
      } else slot.style.opacity = 0.5;
      slots.appendChild(slot);
    });
    block.appendChild(slots);
    collectionsArea.appendChild(block);
  });
}

/* periodic money UI update fallback */
setInterval(() => {
  if (myId && players[myId]) moneyVal.textContent = Math.floor(players[myId].money || 30);
}, 500);

/* render helpers that call both */
function renderPlayerList() { /* noop, collections renders players as well */ }

/* public interface: safeSend wrapper is above */

/* EXPOSE */
window._localWalkers = localWalkers;

/* Start UI modal visible on page load */
usernameModal.style.display = 'flex';
</script>
</body>
</html>
